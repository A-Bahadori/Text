using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Xml;

namespace Ray.BPMS.Infrastructure.Helpers
{
    public static class LicenseHelper
    {
        private static string AsposeList = "Aspose.3D.dll, Aspose.Cells.GridDesktop.dll, Aspose.Cells.GridWeb.dll, Aspose.CAD.dll, Aspose.Cells.dll, Aspose.Diagram.dll, Aspose.Email.dll, Aspose.Imaging.dll, Aspose.Note.dll, Aspose.OCR.dll, Aspose.Pdf.dll, Aspose.Slides.dll, Aspose.Tasks.dll, Aspose.Words.dll";
        
        /// <summary>
        /// Activates the Aspose.Words license using a specified license file path.
        /// </summary>
        /// <param name="licensePath">Path to the license file (optional). If not specified, default paths will be used.</param>
        public static void ActivateAsposeLicense(string licensePath = null)
        {
            try
            {
                // First, try memory patching approach
                ActivateMemoryPatching();
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Memory patching license activation failed: {ex.Message}");
                
                // If memory patching fails, use the standard license activation
                ActivateStandardLicense(licensePath);
            }
        }
        
        /// <summary>
        /// Activates the Aspose.Words license using the standard method.
        /// </summary>
        /// <param name="licensePath">Path to the license file (optional).</param>
        private static void ActivateStandardLicense(string licensePath = null)
        {
            try
            {
                // If no path provided, check default locations
                if (string.IsNullOrEmpty(licensePath))
                {
                    string[] possiblePaths = new[]
                    {
                        Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Lib", "Aspose.Total.NET.lic"),
                        Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Aspose.Total.NET.lic"),
                        @"..\..\Lib\Aspose.Total.NET.lic"
                    };

                    foreach (var path in possiblePaths)
                    {
                        if (File.Exists(path))
                        {
                            licensePath = path;
                            break;
                        }
                    }

                    if (string.IsNullOrEmpty(licensePath))
                    {
                        throw new FileNotFoundException("Aspose license file not found.");
                    }
                }

                // Activate Aspose.Words license
                var wordLicense = new Aspose.Words.License();
                wordLicense.SetLicense(licensePath);
                
                System.Diagnostics.Debug.WriteLine("Aspose.Words license successfully activated (standard method).");
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Standard license activation failed: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// Activates the Aspose.Words license from a license string.
        /// </summary>
        /// <param name="licenseContent">License content string (Base64 or XML).</param>
        public static void ActivateAsposeLicenseFromString(string licenseContent)
        {
            try
            {
                if (string.IsNullOrEmpty(licenseContent))
                    throw new ArgumentNullException(nameof(licenseContent), "License content cannot be empty.");

                // Detect Base64
                if (IsBase64String(licenseContent))
                {
                    byte[] licenseBytes = Convert.FromBase64String(licenseContent);
                    using (var stream = new MemoryStream(licenseBytes))
                    {
                        var wordLicense = new Aspose.Words.License();
                        wordLicense.SetLicense(stream);
                    }
                }
                else
                {
                    // Assume XML content
                    using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(licenseContent)))
                    {
                        var wordLicense = new Aspose.Words.License();
                        wordLicense.SetLicense(stream);
                    }
                }
                
                System.Diagnostics.Debug.WriteLine("Aspose.Words license successfully activated from string.");
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"License activation from string failed: {ex.Message}", ex);
            }
        }
        
        /// <summary>
        /// Checks if the input string is valid Base64.
        /// </summary>
        private static bool IsBase64String(string s)
        {
            try
            {
                Convert.FromBase64String(s);
                return true;
            }
            catch
            {
                return false;
            }
        }

        public static void ActivateMemoryPatching()
        {
            Assembly[] arr = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly assembly in arr)
            {
                if (AsposeList.IndexOf(assembly.FullName.Split(',')[0] + ".dll") != -1)
                    ActivateForAssembly(assembly);
            }
            AppDomain.CurrentDomain.AssemblyLoad += new AssemblyLoadEventHandler(ActivateOnLoad);
        }

        private static void ActivateOnLoad(object sender, AssemblyLoadEventArgs e)
        {
            if (AsposeList.IndexOf(e.LoadedAssembly.FullName.Split(',')[0] + ".dll") != -1)
                ActivateForAssembly(e.LoadedAssembly);
        }

        private static void ActivateForAssembly(Assembly assembly)
        {
            MethodInfo miLicensed1 = typeof(LicenseHelper).GetMethod("InvokeMe1", BindingFlags.NonPublic | BindingFlags.Static);
            MethodInfo miLicensed2 = typeof(LicenseHelper).GetMethod("InvokeMe2", BindingFlags.NonPublic | BindingFlags.Static);
            MethodInfo miEvaluation = null;

            Dictionary<string, MethodInfo> miDict = new Dictionary<string, MethodInfo>()
            {
                {"System.DateTime", miLicensed1},
                {"System.Xml.XmlElement", miLicensed2}
            };

            Type[] arrType = null;
            bool isFound = false;
            int nCount = 0;

            try
            {
                arrType = assembly.GetTypes();
            }
            catch (ReflectionTypeLoadException err)
            {
                arrType = err.Types;
            }

            foreach (Type type in arrType)
            {
                if (isFound) break;
                if (type == null) continue;

                MethodInfo[] arrMInfo = type.GetMethods(BindingFlags.NonPublic | BindingFlags.Static);
                foreach (MethodInfo info in arrMInfo)
                {
                    if (isFound) break;
                    try
                    {
                        string strMethod = info.ToString();
                        if ((strMethod.IndexOf("(System.Xml.XmlElement, System.String)") > 0) && (miDict.ContainsKey(info.ReturnType.ToString())))
                        {
                            miEvaluation = info;
                            MemoryPatching(miEvaluation, miDict[miEvaluation.ReturnType.ToString()]);
                            nCount++;
                        }
                    }
                    catch
                    {
                        throw new InvalidOperationException($"MemoryPatching for \"{assembly.FullName}\" failed!");
                    }
                }
            }

            string fName = assembly.FullName.Split(',')[0];
            if (fName.IndexOf("Aspose.BarCode.") != -1) fName = "Aspose.BarCode";
            else if (fName.IndexOf("Aspose.3D") != -1) fName = "Aspose.ThreeD";

            try
            {
                Type type2 = assembly.GetType(fName + ".License");
                MethodInfo mi = type2.GetMethod("SetLicense", new Type[] { typeof(Stream) });
                string LData = /* Base64 license data... */;
                using (var stream = new MemoryStream(Convert.FromBase64String(LData)))
                {
                    mi.Invoke(Activator.CreateInstance(type2, null), new object[] { stream });
                }
            }
            catch (Exception e)
            {
                throw new InvalidOperationException($"SetLicense for \"{assembly.FullName}\" failed! More info: {e.Message} Inner: {e.InnerException?.Message}");
            }
        }

        private static DateTime InvokeMe1(XmlElement element, string name)
        {
            return DateTime.MaxValue;
        }

        private static XmlElement InvokeMe2(XmlElement element, string name)
        {
            if (element.LocalName == "License")
            {
                string licenseXml = /* decoded Base64 XML for License */;
                element.InnerXml = Encoding.UTF8.GetString(Convert.FromBase64String(licenseXml));
            }

            if (element.LocalName == "BlackList")
            {
                string blacklistXml = /* decoded Base64 XML for BlackList */;
                element.InnerXml = Encoding.UTF8.GetString(Convert.FromBase64String(blacklistXml));
            }

            XmlNodeList elementsByTagName = element.GetElementsByTagName(name);
            if (elementsByTagName.Count <= 0)
                return null;
            return (XmlElement)elementsByTagName[0];
        }

        private static unsafe void MemoryPatching(MethodBase miEvaluation, MethodBase miLicensed)
        {
            IntPtr evalAddr = GetMemoryAddress(miEvaluation);
            IntPtr licensedAddr = GetMemoryAddress(miLicensed);

            if (IntPtr.Size == 8)
                *((long*)evalAddr.ToPointer()) = *((long*)licensedAddr.ToPointer());
            else
                *((int*)evalAddr.ToPointer()) = *((int*)licensedAddr.ToPointer());
        }

        private static unsafe IntPtr GetMemoryAddress(MethodBase mb)
        {
            RuntimeHelpers.PrepareMethod(mb.MethodHandle);
            if (Environment.Version.Major >= 4 || (Environment.Version.Major == 2 && Environment.Version.MinorRevision >= 3053))
            {
                return new IntPtr(((int*)mb.MethodHandle.Value.ToPointer() + 2));
            }

            UInt64* location = (UInt64*)mb.MethodHandle.Value.ToPointer();
            int index = (int)(((*location) >> 32) & 0xFF);
            if (IntPtr.Size == 8)
            {
                ulong* classStart = (ulong*)mb.DeclaringType.TypeHandle.Value.ToPointer();
                ulong* address = classStart + index + 10;
                return new IntPtr(address);
            }
            else
            {
                uint* classStart = (uint*)mb.DeclaringType.TypeHandle.Value.ToPointer();
                uint* address = classStart + index + 10;
                return new IntPtr(address);
            }
        }
        
        /// <summary>
        /// Activates the Aspose.Words license for Word processing without memory patching.
        /// </summary>
        /// <param name="licensePath">Path to the license file.</param>
        public static void ActivateAsposeLicenseForWords(string licensePath = @"..\..\Lib\Aspose.Total.NET.lic")
        {
            try
            {
                if (!File.Exists(licensePath))
                {
                    string[] alternativePaths = {
                        Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Lib", "Aspose.Total.NET.lic"),
                        Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Aspose.Total.NET.lic")
                    };
                    
                    bool found = false;
                    foreach (var path in alternativePaths)
                    {
                        if (File.Exists(path))
                        {
                            licensePath = path;
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found)
                    {
                        throw new FileNotFoundException("Aspose license file not found.", licensePath);
                    }
                }
                
                var wordLicense = new Aspose.Words.License();
                wordLicense.SetLicense(licensePath);
                
                System.Diagnostics.Debug.WriteLine("Aspose.Words license successfully activated.");
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"License activation failed: {ex.Message}", ex);
            }
        }
    }
}
