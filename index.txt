using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using System.Xml.Linq;

var builder = new ServiceCollection()
    .AddLogging(logging =>
    {
        logging.AddConsole();
        logging.SetMinimumLevel(LogLevel.Information);
    })
    .AddSingleton<IProjectAnalyzer, ProjectAnalyzer>()
    .AddSingleton<IProjectFinder, ProjectFinder>()
    .AddSingleton<IProjectParser, ProjectParser>()
    .AddSingleton<IReferenceWriter, ReferenceWriter>();

var serviceProvider = builder.BuildServiceProvider();
var analyzer = serviceProvider.GetRequiredService<IProjectAnalyzer>();

try
{
    Console.WriteLine("ProjectReferenceMapper v1.0");
    Console.WriteLine("یک ابزار برای نگاشت رفرنس‌های پروژه‌های سی‌شارپ");
    Console.WriteLine("----------------------------------------");

    Console.WriteLine("لطفاً مسیر پروژه را وارد کنید:");
    var projectPath = Console.ReadLine();

    await analyzer.AnalyzeProjectsAsync(projectPath);
}
catch (Exception ex)
{
    Console.WriteLine($"خطای غیرمنتظره: {ex.Message}");
}

// Interfaces
public interface IProjectAnalyzer
{
    Task AnalyzeProjectsAsync(string rootPath);
}

public interface IProjectFinder
{
    IEnumerable<string> FindProjects(string rootPath);
}

public interface IProjectParser
{
    Task<ProjectInfo> ParseProjectAsync(string projectFile);
}

public interface IReferenceWriter
{
    Task WriteReferencesAsync(ProjectInfo projectInfo);
}

// Implementation Classes
public sealed class ProjectAnalyzer : IProjectAnalyzer
{
    private readonly ILogger<ProjectAnalyzer> _logger;
    private readonly IProjectFinder _projectFinder;
    private readonly IProjectParser _projectParser;
    private readonly IReferenceWriter _referenceWriter;

    public ProjectAnalyzer(
        ILogger<ProjectAnalyzer> logger,
        IProjectFinder projectFinder,
        IProjectParser projectParser,
        IReferenceWriter referenceWriter) =>
        (_logger, _projectFinder, _projectParser, _referenceWriter) = 
        (logger, projectFinder, projectParser, referenceWriter);

    public async Task AnalyzeProjectsAsync(string rootPath)
    {
        ArgumentException.ThrowIfNullOrEmpty(rootPath);

        if (!Directory.Exists(rootPath))
        {
            throw new DirectoryNotFoundException("مسیر مورد نظر یافت نشد.");
        }

        _logger.LogInformation("شروع تحلیل پروژه‌ها در مسیر: {Path}", rootPath);

        var projectFiles = _projectFinder.FindProjects(rootPath);
        var tasks = new List<Task>();

        foreach (var projectFile in projectFiles)
        {
            tasks.Add(ProcessProjectAsync(projectFile));
        }

        await Task.WhenAll(tasks);
        _logger.LogInformation("تحلیل پروژه‌ها با موفقیت به پایان رسید.");
    }

    private async Task ProcessProjectAsync(string projectFile)
    {
        try
        {
            _logger.LogInformation("در حال پردازش پروژه: {Project}", Path.GetFileName(projectFile));
            var projectInfo = await _projectParser.ParseProjectAsync(projectFile);
            await _referenceWriter.WriteReferencesAsync(projectInfo);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "خطا در پردازش پروژه {Project}", projectFile);
        }
    }
}

public sealed class ProjectFinder : IProjectFinder
{
    public IEnumerable<string> FindProjects(string rootPath) =>
        Directory.EnumerateFiles(rootPath, "*.csproj", SearchOption.AllDirectories);
}

public sealed class ProjectParser : IProjectParser
{
    public async Task<ProjectInfo> ParseProjectAsync(string projectFile)
    {
        var doc = await XDocument.LoadAsync(
            File.OpenRead(projectFile), 
            LoadOptions.None, 
            CancellationToken.None);

        var root = doc.Root;
        var isSdkStyle = root?.Attribute("Sdk") is not null;

        var references = new List<ReferenceInfo>();
        if (root is not null)
        {
            if (isSdkStyle)
            {
                references.AddRange(GetPackageReferences(root));
                references.AddRange(GetProjectReferences(root));
            }
            else
            {
                references.AddRange(GetLegacyReferences(root));
                references.AddRange(GetProjectReferences(root));
            }
        }

        return new ProjectInfo(
            Path.GetFileNameWithoutExtension(projectFile),
            projectFile,
            isSdkStyle,
            references);
    }

    private static IEnumerable<ReferenceInfo> GetPackageReferences(XElement root) =>
        root.Descendants("PackageReference")
            .Select(x => new ReferenceInfo(
                ReferenceType.Package,
                x.Attribute("Include")?.Value,
                x.Attribute("Version")?.Value));

    private static IEnumerable<ReferenceInfo> GetProjectReferences(XElement root) =>
        root.Descendants("ProjectReference")
            .Select(x => new ReferenceInfo(
                ReferenceType.Project,
                path: x.Attribute("Include")?.Value));

    private static IEnumerable<ReferenceInfo> GetLegacyReferences(XElement root) =>
        root.Descendants()
            .Where(x => x.Name.LocalName == "Reference")
            .Select(x => new ReferenceInfo(
                ReferenceType.Assembly,
                name: x.Attribute("Include")?.Value));
}

public sealed class ReferenceWriter : IReferenceWriter
{
    public async Task WriteReferencesAsync(ProjectInfo projectInfo)
    {
        var outputPath = Path.Combine(
            Path.GetDirectoryName(projectInfo.ProjectPath)!, 
            $"{projectInfo.ProjectName}_References.txt"
        );

        var content = new List<string>
        {
            "ProjectReferenceMapper - گزارش رفرنس‌ها",
            $"تاریخ ایجاد: {DateTime.Now}",
            $"نام پروژه: {projectInfo.ProjectName}",
            $"نوع پروژه: {(projectInfo.IsSdkStyle ? "SDK-Style" : "Legacy")}",
            $"مسیر پروژه: {projectInfo.ProjectPath}",
            "----------------------------------------",
            string.Empty,
            "لیست رفرنس‌ها:",
            string.Empty
        };

        content.AddRange(projectInfo.References.Select(FormatReference));

        await File.WriteAllLinesAsync(outputPath, content);
    }

    private static string FormatReference(ReferenceInfo reference) => reference.Type switch
    {
        ReferenceType.Package => $"Package: {reference.Name} - Version: {reference.Version}",
        ReferenceType.Project => $"Project: {reference.Path}",
        ReferenceType.Assembly => $"Assembly: {reference.Name}",
        _ => throw new ArgumentException($"نوع رفرنس نامعتبر: {reference.Type}")
    };
}

// Records and Enums
public sealed record ProjectInfo(
    string ProjectName,
    string ProjectPath,
    bool IsSdkStyle,
    IEnumerable<ReferenceInfo> References);

public sealed record ReferenceInfo(
    ReferenceType Type,
    string? Name = null,
    string? Version = null,
    string? Path = null);

public enum ReferenceType
{
    Package,
    Project,
    Assembly
}
