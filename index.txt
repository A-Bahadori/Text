// This script targets .NET 8 and processes multiple .csproj files.
// You can choose one of three modes:
//   F: Select one or more .csproj files directly.
//   D: Select a folder; all .csproj files in the folder (recursively) will be processed.
//   S: Select a solution file (.sln); its directory will be scanned for .csproj files.
// Each file is backed up (a .bak file is created) before cleaning.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using System.Windows.Forms;

// Helper function to show an input box.
string GetInput(string prompt, string defaultValue = "")
{
    return Microsoft.VisualBasic.Interaction.InputBox(prompt, "Input", defaultValue);
}

// Helper function to select one or more files.
string[] SelectFiles(string title, string filterExt)
{
    using (OpenFileDialog dialog = new OpenFileDialog())
    {
        dialog.Title = title;
        dialog.Filter = $"{filterExt.ToUpper()} Files (*.{filterExt})|*.{filterExt}|All Files (*.*)|*.*";
        dialog.Multiselect = true;
        if (dialog.ShowDialog() == DialogResult.OK)
            return dialog.FileNames;
        return Array.Empty<string>();
    }
}

// Helper function to select a folder.
string SelectFolder(string description)
{
    using (FolderBrowserDialog dialog = new FolderBrowserDialog())
    {
        dialog.Description = description;
        if (dialog.ShowDialog() == DialogResult.OK)
            return dialog.SelectedPath;
        return null;
    }
}

// Helper function to open a single file.
string OpenFile(string title, string filterExt)
{
    using (OpenFileDialog dialog = new OpenFileDialog())
    {
        dialog.Title = title;
        dialog.Filter = $"{filterExt.ToUpper()} Files (*.{filterExt})|*.{filterExt}|All Files (*.*)|*.*";
        dialog.Multiselect = false;
        if (dialog.ShowDialog() == DialogResult.OK)
            return dialog.FileName;
        return null;
    }
}

void Main()
{
    // Ask the user which mode to use.
    var mode = GetInput("Enter 'F' to select csproj file(s), 'D' to select a folder, or 'S' to select a solution file (.sln):", "F").Trim();
    List<string> csprojFiles = new();

    if (mode.Equals("F", StringComparison.OrdinalIgnoreCase))
    {
        // Select one or more .csproj files.
        var files = SelectFiles("Select one or more .csproj files", "csproj");
        if (files.Length == 0)
        {
            "No csproj files selected.".Dump();
            return;
        }
        csprojFiles.AddRange(files);
    }
    else if (mode.Equals("D", StringComparison.OrdinalIgnoreCase))
    {
        // Select a folder and find all .csproj files recursively.
        var folder = SelectFolder("Select a folder containing your solution/projects");
        if (string.IsNullOrWhiteSpace(folder))
        {
            "No folder selected.".Dump();
            return;
        }
        csprojFiles.AddRange(Directory.GetFiles(folder, "*.csproj", SearchOption.AllDirectories));
        if (csprojFiles.Count == 0)
        {
            "No csproj files found in the selected folder.".Dump();
            return;
        }
    }
    else if (mode.Equals("S", StringComparison.OrdinalIgnoreCase))
    {
        // Select a solution file (.sln) and use its directory to locate .csproj files.
        var slnFile = OpenFile("Select a solution file (.sln)", "sln");
        if (string.IsNullOrWhiteSpace(slnFile))
        {
            "No solution file selected.".Dump();
            return;
        }
        var folder = Path.GetDirectoryName(slnFile);
        csprojFiles.AddRange(Directory.GetFiles(folder, "*.csproj", SearchOption.AllDirectories));
        if (csprojFiles.Count == 0)
        {
            "No csproj files found in the solution folder.".Dump();
            return;
        }
    }
    else
    {
        "Invalid option selected. Please enter 'F', 'D', or 'S'.".Dump();
        return;
    }

    int processedCount = 0;
    int modifiedCount = 0;

    foreach (var filePath in csprojFiles)
    {
        try
        {
            // Create a backup of the file.
            File.Copy(filePath, filePath + ".bak", overwrite: true);
            $"Backup created for {Path.GetFileName(filePath)}.".Dump();

            // Load the XML content of the csproj file.
            XDocument xdoc = XDocument.Load(filePath);
            bool modified = false;

            // Identify redundant elements:
            // Elements with names "Compile", "Content", "None", or "EmbeddedResource"
            // that have an Include attribute, no child elements (i.e. no metadata),
            // and do not contain wildcards (e.g. '*') are considered redundant.
            var redundantElements = xdoc.Descendants()
                .Where(e => (e.Name.LocalName == "Compile" ||
                             e.Name.LocalName == "Content" ||
                             e.Name.LocalName == "None" ||
                             e.Name.LocalName == "EmbeddedResource") &&
                            e.Attribute("Include") is not null &&
                            !e.HasElements &&
                            !e.Attribute("Include").Value.Contains("*"))
                .ToList();

            // Remove the redundant elements.
            foreach (var elem in redundantElements)
            {
                elem.Remove();
                modified = true;
            }

            // Save changes if modifications were made.
            if (modified)
            {
                xdoc.Save(filePath);
                $"Cleaned {Path.GetFileName(filePath)}.".Dump();
                modifiedCount++;
            }
            else
            {
                $"No redundant items found in {Path.GetFileName(filePath)}.".Dump();
            }
            processedCount++;
        }
        catch (Exception ex)
        {
            $"Error processing {Path.GetFileName(filePath)}: {ex.Message}".Dump();
        }
    }

    $"Processed {processedCount} file(s), modified {modifiedCount} file(s).".Dump();
}
